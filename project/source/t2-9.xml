<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd'>
<nta>
	<declaration>
// Place global declarations here.
//Config

const int N = 9;
const int P = 2;

typedef int [0,N-1] tid_t;//task id
typedef int [0,P-1] pid_t;///processor id
const int MaxTime=500;
typedef int [0,MaxTime] time_t;//The maximum time constant for all tasks,this is used of UPPAAL state footprint reduction.
const int BUFFERSIZE=30;//the maximu buffersize
const int BUSSIZE=20; 

const int Policies      = 3;
const int EDF       = 0;
///const int FIFO       = 1;
const int RMS       = 1;
typedef int[0,Policies-1] policy_t;
typedef struct{
    pid_t pid;
    policy_t policy;
    bool preemptive;
}processor;
typedef processor processors[pid_t]; 
int [-1,N] cpuQueue[P][BUFFERSIZE];
clock time[N];//
///clock exec[N];//
///clock respt[N];
clock cpuUsed[P];
///bool released[N];
////bool running[N];
bool error=false;
///Data structer to keep task's attributes
typedef struct{
    time_t init_offset;//the time offset for the task first released;
    time_t bcet;//best case execution time of task.
    time_t wcet;//worst case execution time of task.
    time_t deadline;//the relative deadline,calculate at the period starts.
    time_t period;//period of the task
    pid_t pe;//the processor requset to run the task
    }task_t;
typedef struct{
    bool release;
    tid_t source;
    tid_t destination;
}msg;
msg busQueue[BUSSIZE];
void addMsg(tid_t source,tid_t destination){
    int [0,BUFFERSIZE-1] temp=0;
    while(busQueue[temp].release) temp++;
    busQueue[temp].release=1;
    busQueue[temp].source=source;
    busQueue[temp].destination=destination;
    temp=0;
}
meta struct{
    meta tid_t task;
    meta bool preemptive;
}param;
void setParam(tid_t t,bool p){
    param.task=t;
    param.preemptive=p;
}
bool empty(pid_t pid){return cpuQueue[pid][0]==-1;}
void insertQueue(pid_t pid,tid_t tid,int[0,BUFFERSIZE-1] index){
    for(i:int [1,BUFFERSIZE]) if(BUFFERSIZE-i&gt;index) cpuQueue[pid][BUFFERSIZE-i]=cpuQueue[pid][BUFFERSIZE-i-1];
    cpuQueue[pid][index]=tid;
}
broadcast chan check_dep[N],dep_ack[N];//chan used for checke dependency;
broadcast chan check_pe[N];//chan used for check resource;
broadcast chan sch_pol[P][Policies];
//urgent broadcast chan run[N],preempt[N];//chan used for schedul the task;
broadcast chan finish[N];//chan used to indicate the task has finishd;
urgent broadcast  chan run[N],preempt[N];
urgent broadcast chan urg;//used to performe urgent activate
int[0,1] dynDep[N][N];
//Config staDep and task
//original tasks dependency;
const int [0,1] staDep[N][N]={
	{0,0,0,0,0,0,0,0,0},
	{1,0,0,0,0,0,0,0,0},
	{1,0,0,0,0,0,0,0,0},
	{1,0,0,0,0,0,0,0,0},
	{0,1,1,1,0,0,0,0,0},
	{0,1,0,0,1,0,0,0,0},
	{0,0,1,0,0,0,0,0,0},
	{0,1,0,0,0,1,0,0,0},
	{1,0,1,0,0,0,1,0,0}
};
const task_t Tasks[N]={
	{0,2,2,20,20,0},
	{0,3,3,10,10,1},
	{0,4,4,12,12,0},
	{0,5,5,12,12,1},
	{0,6,6,16,16,0},
	{0,5,5,16,16,1},
	{0,3,4,20,20,0},
	{0,4,5,20,20,1},
	{0,2,3,18,18,0}
};
//</declaration>
	<template>
		<name x="9" y="9">Task</name>
		<parameter>const tid_t id</parameter>
		<declaration>// Place local declarations here.
clock exec;
clock respt;
time_t InitOffset(){return Tasks[id].init_offset;}
time_t Bcet(){return Tasks[id].bcet;}
time_t Wcet(){return Tasks[id].wcet;}
time_t DeadLine(){return Tasks[id].deadline;}
time_t Period(){ return Tasks[id].period;}</declaration>
		<location id="id0" x="-272" y="-93">
			<name x="-255" y="-110">Ready</name>
			<label kind="invariant" x="-263" y="-84">time[id]&lt;=Period()
&amp;&amp;exec'==0</label>
		</location>
		<location id="id1" x="-510" y="-263" color="#ff0000">
			<name x="-501" y="-288">Error</name>
			<label kind="invariant" x="-561" y="-246">exec'==0&amp;&amp;respt'==0</label>
		</location>
		<location id="id2" x="-697" y="-262">
			<name x="-680" y="-271">Finish</name>
			<label kind="invariant" x="-739" y="-236">!error&amp;&amp;time[id]&lt;=Period()
&amp;&amp;exec'==0&amp;&amp;respt'==0</label>
		</location>
		<location id="id3" x="-510" y="-93">
			<name x="-569" y="-118">Running</name>
			<label kind="invariant" x="-604" y="-84">exec&lt;=Wcet()&amp;&amp;time[id]&lt;=Period()</label>
		</location>
		<location id="id4" x="-272" y="-263">
			<name x="-340" y="-254">DependencyResolved</name>
			<urgent/>
		</location>
		<location id="id5" x="-510" y="-408">
			<name x="-493" y="-408">WaitingDepedency</name>
			<label kind="invariant" x="-501" y="-391">time[id]&lt;=Period()&amp;&amp;exec'==0</label>
		</location>
		<location id="id6" x="-510" y="-510">
			<name x="-519" y="-544">Initial</name>
			<label kind="invariant" x="-493" y="-518">time[id]&lt;=InitOffset()</label>
		</location>
		<init ref="id6"/>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="guard" x="-408" y="-212">time[id]&gt;DeadLine()</label>
			<label kind="assignment" x="-391" y="-195">error=true</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-425" y="-59">preempt[id]?</label>
			<nail x="-510" y="-33"/>
			<nail x="-272" y="-33"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-391" y="-118">run[id]?</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-263" y="-170">check_pe[id]!</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id1"/>
			<label kind="guard" x="-501" y="-170">time[id]&gt;DeadLine()</label>
			<label kind="assignment" x="-501" y="-153">error=true</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id1"/>
			<label kind="guard" x="-501" y="-348">time[id]&gt;DeadLine()</label>
			<label kind="assignment" x="-501" y="-331">error=true</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id5"/>
			<label kind="guard" x="-688" y="-382">time[id]==Period()</label>
			<label kind="synchronisation" x="-688" y="-365">check_dep[id]!</label>
			<label kind="assignment" x="-688" y="-348">time[id]=0</label>
			<nail x="-697" y="-408"/>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="guard" x="-688" y="-178">exec&gt;=Bcet()</label>
			<label kind="synchronisation" x="-688" y="-161">finish[id]!</label>
			<label kind="assignment" x="-688" y="-144">exec=0,
respt=0</label>
			<nail x="-697" y="-93"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-272" y="-331">dep_ack[id]?</label>
			<nail x="-272" y="-408"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id5"/>
			<label kind="guard" x="-501" y="-484">time[id]==InitOffset()</label>
			<label kind="synchronisation" x="-501" y="-467">check_dep[id]!</label>
			<label kind="assignment" x="-501" y="-450">time[id]=0,exec=0,respt=0</label>
		</transition>
	</template>
	<template>
		<name>DepManager</name>
		<declaration>int[-1,N] queue[BUFFERSIZE];
///int [0,BUFFERSIZE] currt;
meta tid_t q;//meta variable too hold the current task id;
void Initial(){
    for(i:int[0,BUFFERSIZE-1]) queue[i]=-1;
    for(i:tid_t) for(j:tid_t) dynDep[i][j]=0;
   //// currt=0;
}
bool full(){
   /// return currt&gt;=BUFFERSIZE-1;
    return queue[BUFFERSIZE-1]!=-1;
}
void enQueue(tid_t id){
   /// queue[currt]=id;
    ////currt++;
    int i;
    i=0;
    while(queue[i]!=-1)i++;
    queue[i]=id;
}
void deQueue(int index){
    
    for(i:int[0,BUFFERSIZE-1]){
        if(i&gt;index) queue[i-1]=queue[i];
    }
    queue[BUFFERSIZE-1]=-1;
   /// currt--;
}
//To find the first task that all dependcy has resolved;
bool depAck(){
   //// int i;
    for(i:int[0,BUFFERSIZE-1]){
       if(queue[i]&gt;=0) {if(forall (j:tid_t) staDep[queue[i]][j] imply dynDep[queue[i]][j]) return true;}
    }
    return false;
}
int[-1,BUFFERSIZE-1] firstDepAck(){
    int[0,N] temp;
    for(i:int [0,BUFFERSIZE-1]){
      if(queue[i]&gt;=0){  
            if(forall (j:tid_t) staDep[queue[i]][j] imply dynDep[queue[i]][j]){
                temp=queue[i];
                deQueue(i);
                return temp;}
      }
    }
    return -1;
}

//upadte the dynmaic dependcy matrix when the find a task who's dependcy is resolved;
void depAckUpdate(int i){
    for(j:tid_t){ if(staDep[i][j])dynDep[i][j]=false;}
}
//upadte the dynamci dependcy matrix when receiving a finish chan;
void finishUpdate(tid_t i){
   //// for(j:tid_t){ if(staDep[j][i]==1&amp;&amp;dynDep[j][i]==0)  dynDep[j][i]++;}///with out dynDep[j][i]==0 it indicate the producer-consumer problem.
        for(j:tid_t){ 
                        if(staDep[j][i]==1&amp;&amp;dynDep[j][i]==0){
                            if(Tasks[j].pe==Tasks[i].pe) dynDep[j][i]=true;
                            else addMsg(j,i);
                                }
                        }
}</declaration>
		<location id="id7" x="-442" y="-306">
			<name x="-450" y="-340">overflow</name>
		</location>
		<location id="id8" x="-442" y="-68">
			<name x="-467" y="-59">DepAck</name>
			<committed/>
		</location>
		<location id="id9" x="-306" y="-204">
			<name x="-297" y="-187">InUse</name>
		</location>
		<location id="id10" x="-306" y="-306">
			<name x="-314" y="-340">Idle</name>
			<committed/>
		</location>
		<init ref="id10"/>
		<transition>
			<source ref="id9"/>
			<target ref="id9"/>
			<label kind="select" x="-238" y="-119">t:tid_t</label>
			<label kind="synchronisation" x="-246" y="-102">finish[t]?</label>
			<label kind="assignment" x="-272" y="-85">finishUpdate(t)</label>
			<nail x="-306" y="-68"/>
			<nail x="-170" y="-68"/>
			<nail x="-170" y="-170"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id9"/>
			<label kind="select" x="-238" y="-280">t:tid_t</label>
			<label kind="guard" x="-238" y="-263">!full()</label>
			<label kind="synchronisation" x="-263" y="-246">check_dep[t]?</label>
			<label kind="assignment" x="-255" y="-229">enQueue(t)</label>
			<nail x="-238" y="-306"/>
			<nail x="-170" y="-306"/>
			<nail x="-170" y="-204"/>
			<nail x="-212" y="-204"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id7"/>
			<label kind="select" x="-433" y="-272">t:tid_t</label>
			<label kind="guard" x="-433" y="-255">full()</label>
			<label kind="synchronisation" x="-433" y="-238">check_dep[t]?</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="-399" y="-110">dep_ack[q]!</label>
			<label kind="assignment" x="-433" y="-93">depAckUpdate(q)</label>
			<nail x="-323" y="-68"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="guard" x="-433" y="-187">depAck()</label>
			<label kind="synchronisation" x="-433" y="-170">urg!</label>
			<label kind="assignment" x="-433" y="-153">q=firstDepAck()</label>
			<nail x="-442" y="-204"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id9"/>
			<label kind="assignment" x="-323" y="-280">Initial()</label>
		</transition>
	</template>
	<template>
		<name>BUS</name>
		<parameter>time_t bus_bect,time_t bus_wect</parameter>
		<declaration>/////int [-1,N] busQueue[BUFFERSIZE];
/*typedef struct{
    bool release;
    tid_t source;
    tid_t destination;
}msg;*/
clock busExec;
void Initial(){
     for(i:int[0,BUSSIZE-1]) busQueue[i].release=0;
 }
bool empty(){
    return !busQueue[0].release;
}
void receive(){
     dynDep[busQueue[0].source][busQueue[0].destination]=true;
     for(i:int[0,BUSSIZE-2]){
         busQueue[i].release=busQueue[i+1].release;
         busQueue[i].source=busQueue[i+1].source;
         busQueue[i].destination=busQueue[i+1].destination;  
    }
    busQueue[BUSSIZE-1].release=0;
}</declaration>
		<location id="id11" x="-807" y="-425">
			<name x="-790" y="-433">Finish</name>
			<committed/>
		</location>
		<location id="id12" x="-671" y="-578">
			<name x="-681" y="-612">Init</name>
			<committed/>
		</location>
		<location id="id13" x="-671" y="-340">
			<name x="-654" y="-348">Trans</name>
			<label kind="invariant" x="-739" y="-331">busExec&lt;=bus_wect</label>
		</location>
		<location id="id14" x="-671" y="-510">
			<name x="-654" y="-518">Idle</name>
			<label kind="invariant" x="-663" y="-493">busExec'==0</label>
		</location>
		<init ref="id12"/>
		<transition>
			<source ref="id11"/>
			<target ref="id14"/>
			<label kind="assignment" x="-807" y="-484">receive(),busExec=0</label>
			<nail x="-807" y="-510"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id14"/>
			<label kind="assignment" x="-663" y="-561">Initial()</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id11"/>
			<label kind="guard" x="-807" y="-374">busExec&gt;=bus_bect</label>
			<nail x="-807" y="-340"/>
			<nail x="-807" y="-348"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id13"/>
			<label kind="guard" x="-663" y="-459">!empty()</label>
			<label kind="synchronisation" x="-663" y="-442">urg!</label>
			<label kind="assignment" x="-663" y="-425">busExec=0</label>
		</transition>
	</template>
	<template>
		<name>Scheduler</name>
		<parameter>const processors pes </parameter>
		<declaration>tid_t tid;
int [-1,P] pe=-1;
int [-1,N] oldid=-1;
int [-1,N] runningid=-1;
void Initial(){
    for(i:pid_t) for(j: int[0,BUFFERSIZE-1]) cpuQueue[i][j]=-1;
}
void popOut(pid_t pe){
    for(i:int[0,BUFFERSIZE-2]) cpuQueue[pe][i]=cpuQueue[pe][i+1];
    cpuQueue[pe][BUFFERSIZE-1]=-1;
}
void setLocal(){
    pe=oldid=runningid=-1;
}
</declaration>
		<location id="id15" x="-1054" y="-680">
			<name x="-1045" y="-705">Finish</name>
			<committed/>
		</location>
		<location id="id16" x="-501" y="-578">
			<committed/>
		</location>
		<location id="id17" x="-204" y="-680">
			<name x="-255" y="-663">Inserted</name>
			<committed/>
		</location>
		<location id="id18" x="-425" y="-680">
			<name x="-459" y="-663">WaitPolicy</name>
			<urgent/>
		</location>
		<location id="id19" x="-646" y="-680">
			<name x="-671" y="-663">Received</name>
			<committed/>
		</location>
		<location id="id20" x="-816" y="-680">
			<name x="-824" y="-654">Idle</name>
		</location>
		<location id="id21" x="-816" y="-748">
			<name x="-826" y="-782">Init</name>
			<committed/>
		</location>
		<init ref="id21"/>
		<transition>
			<source ref="id15"/>
			<target ref="id20"/>
			<label kind="guard" x="-1003" y="-807">runningid!=-1</label>
			<label kind="synchronisation" x="-1003" y="-782">run[runningid]!</label>
			<label kind="assignment" x="-986" y="-765">setLocal()</label>
			<nail x="-1054" y="-782"/>
			<nail x="-884" y="-782"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id20"/>
			<label kind="guard" x="-1011" y="-612">runningid==-1</label>
			<label kind="assignment" x="-1003" y="-595">setLocal()</label>
			<nail x="-1054" y="-578"/>
			<nail x="-884" y="-578"/>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id15"/>
			<label kind="select" x="-986" y="-714">t:tid_t</label>
			<label kind="synchronisation" x="-994" y="-697">finish[t]?</label>
			<label kind="assignment" x="-1028" y="-680">pe=Tasks[t].pe,popOut(pe),
runningid=cpuQueue[pe][0]</label>
			<nail x="-986" y="-680"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="-671" y="-612">run[tid]!</label>
			<label kind="assignment" x="-680" y="-595">setLocal()</label>
			<nail x="-748" y="-578"/>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id16"/>
			<label kind="guard" x="-416" y="-646">oldid!=-1&amp;&amp;runningid==tid</label>
			<label kind="synchronisation" x="-365" y="-629">preempt[oldid]!</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id16"/>
			<label kind="guard" x="-280" y="-595">oldid==-1</label>
			<nail x="-204" y="-578"/>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id20"/>
			<label kind="guard" x="-510" y="-807">oldid!=-1&amp;&amp;runningid==oldid</label>
			<label kind="assignment" x="-476" y="-782">setLocal()</label>
			<nail x="-204" y="-782"/>
			<nail x="-748" y="-782"/>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-391" y="-731">sch_pol[pe][pes[pe].policy]?</label>
			<label kind="assignment" x="-391" y="-714">runningid=cpuQueue[pe][0]</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-629" y="-739">sch_pol[pe][pes[pe].policy]!</label>
			<label kind="assignment" x="-629" y="-722">setParam(tid,pes[pe].preemptive),
oldid=cpuQueue[pe][0]</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id19"/>
			<label kind="select" x="-756" y="-714">t:tid_t</label>
			<label kind="synchronisation" x="-782" y="-697">check_pe[t]?</label>
			<label kind="assignment" x="-799" y="-680">tid=t,pe=Tasks[t].pe</label>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id20"/>
			<label kind="assignment" x="-816" y="-731">Initial()</label>
		</transition>
	</template>
	<template>
		<name>policy_EDF</name>
		<declaration>int [0,BUFFERSIZE] pos;
pid_t pid;
tid_t tid;
bool preempt;
void readParam()
{
    tid=param.task;
    preempt=param.preemptive;
}
void resetLocalParam(){
    pid=tid=preempt=pos=0;
}
int [-1,BUFFERSIZE] getTid(int[0,BUFFERSIZE-1] index){
    return cpuQueue[pid][index];
}</declaration>
		<location id="id22" x="-170" y="102">
			<name x="-229" y="77">Inserted</name>
			<committed/>
		</location>
		<location id="id23" x="-170" y="-68">
			<name x="-221" y="-59">Iteration</name>
			<committed/>
		</location>
		<location id="id24" x="-170" y="-238">
			<name x="-153" y="-246">Idle</name>
		</location>
		<init ref="id24"/>
		<transition>
			<source ref="id23"/>
			<target ref="id23"/>
			<label kind="guard" x="-102" y="-110">getTid(pos)!=-1&amp;&amp;
time[tid]-Tasks[tid].deadline
&lt;=time[getTid(pos)]
-Tasks[getTid(pos)].deadline</label>
			<label kind="assignment" x="-144" y="-85">pos++</label>
			<nail x="-102" y="-102"/>
			<nail x="-102" y="-34"/>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id24"/>
			<label kind="synchronisation" x="-323" y="8">sch_pol[pid][EDF]!</label>
			<label kind="assignment" x="-323" y="25">resetLocalParam()</label>
			<nail x="-323" y="102"/>
			<nail x="-323" y="-238"/>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id22"/>
			<label kind="guard" x="-161" y="-8">getTid(pos)==-1||
time[tid]-Tasks[tid].deadline&gt;
time[getTid(pos)]-Tasks[getTid(pos)].deadline</label>
			<label kind="assignment" x="-161" y="59">insertQueue(pid,tid,pos)</label>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id23"/>
			<label kind="select" x="-161" y="-212">p:pid_t</label>
			<label kind="synchronisation" x="-161" y="-195">sch_pol[p][EDF]?</label>
			<label kind="assignment" x="-161" y="-178">pid=p,readParam(),
pos=(preempt ? 0:!empty(p))</label>
		</transition>
	</template>
	<template>
		<name>policy_RMS</name>
		<declaration>pid_t pid;
tid_t tid;
bool preempt;
void readParam(){
   /// pid=param.resource;
    tid=param.task;
    preempt=param.preemptive;
}
int [-1,N] getTid(int[0,N] index){
    return cpuQueue[pid][index];
}
void pol_RMS(){
    int fence=(preempt ? 0:!empty(pid));
    while(getTid(fence)!=-1&amp;&amp;Tasks[tid].period&gt;=Tasks[getTid(fence)].period)  fence++;
    insertQueue(pid,tid,fence); 
}
void resetLocalParam(){
    pid=tid=preempt=0;
}</declaration>
		<location id="id25" x="-68" y="34">
			<name x="-136" y="8">Inserted</name>
			<committed/>
		</location>
		<location id="id26" x="-68" y="-170">
			<name x="-110" y="-161">Idle</name>
		</location>
		<init ref="id26"/>
		<transition>
			<source ref="id25"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-204" y="-34">sch_pol[pid][RMS]!</label>
			<label kind="assignment" x="-204" y="-17">resetLocalParam()</label>
			<nail x="-204" y="34"/>
			<nail x="-204" y="-170"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id25"/>
			<label kind="select" x="-59" y="-127">p:pid_t</label>
			<label kind="synchronisation" x="-59" y="-110">sch_pol[p][RMS]?</label>
			<label kind="assignment" x="-59" y="-93">pid=p,
readParam(),
pol_RMS()</label>
		</transition>
	</template>
	<system>
		// Place template instantiations here.

const processors pes ={
	{0,EDF,true},
	{1,EDF,true}
};
bus = BUS(1,1);


scheduler=Scheduler(pes);
// List one or more processes to be composed into a system.
system Task,DepManager,bus,scheduler,policy_EDF,policy_RMS;</system>
</nta>
